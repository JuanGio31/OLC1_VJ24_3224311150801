package org.example.backend.interprete.analisis;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import org.example.backend.interprete.abstracto.Instruccion;
import org.example.backend.interprete.expresion.*;
import org.example.backend.interprete.error.*;
import org.example.backend.interprete.simbol.*;

import org.example.backend.interprete.instruccion.*;

class Parser;

parser code {:

    public LinkedList<Errores> listaErrores = new LinkedList<>();

//TipoError tipo, String desc, int lineaa, int columaa
    public void syntax_error(Symbol s){
        listaErrores.add(new Errores(
                        TipoError.SINTACTICO,
                        ", Recuperable. No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        listaErrores.add(new Errores(
                        TipoError.SINTACTICO,
                        ", No Recuperable. No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }
:}


//** Simboloes terminal **//
terminal String CADENA, ENTERO, DECIMAL, ID;
terminal LPAREN, RPAREN, TIMES, INT, DOUBLE, BOOL, CHAR, STRING, VAR, CONST, MAS, MENOS, DIVIDE, MOD, UMENOS;
terminal NE, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL, OR, AND, XOR, NOT, IF, ELSE, WHILE, DO, FOR, MATCH, DEFAULT, LBRACE;
terminal RBRACE, FIN_INSTRUCCION, PRINTLN, CARACTER, COMA, DOS_PUNTOS, BOOLEAN, BREAK, CONTINUE, RETURN;
terminal IGUAL, EQ;

//** Simbolos no terminales **//
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion INCREMENTO, DECREMENTO;
nonterminal Instruccion SIF;
nonterminal Instruccion PRINT, DECLARACION, ASIGNACION;
nonterminal Instruccion EXPRESION, CAST;
nonterminal Tipo TIPOS;

//** Precedencia **//
precedence left OR, AND, XOR;
precedence right NOT;
precedence left EQ, NE, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left TIMES, DIVIDE, MOD;
precedence right UMENOS;
precedence right CAST;

//** Definir gramaticas **//
start with INICIO;

INICIO ::= INSTRUCCIONES:a      {:   RESULT = a;   :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b     {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                   {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

INSTRUCCION ::= PRINT: a                {:   RESULT = a;   :}
              | DECLARACION: a          {:   RESULT = a;   :}
              | ASIGNACION: a           {:   RESULT = a;   :}
              | error FIN_INSTRUCCION
;

PRINT ::= PRINTLN LPAREN EXPRESION:a RPAREN FIN_INSTRUCCION      {:     RESULT = new Print(a, aleft, aright);   :}
;

//boolean esConstante, String identificador, Instruccion valor, Tipo tipo, int linea, int columna
DECLARACION ::= CONST ID:b DOS_PUNTOS TIPOS:a IGUAL EXPRESION:c FIN_INSTRUCCION    {:   RESULT = new DeclaracionVariable(true, b, c, a, aleft, aright);    :}
              | VAR ID:b DOS_PUNTOS TIPOS:a IGUAL EXPRESION:c FIN_INSTRUCCION      {:   RESULT = new DeclaracionVariable(false, b, c, a, aleft, aright);   :}
              | CONST ID:a DOS_PUNTOS TIPOS:b FIN_INSTRUCCION                      {:   RESULT = new DeclaracionVariable(true, a, b, aleft, aright);   :}
              | VAR ID:a DOS_PUNTOS TIPOS:b FIN_INSTRUCCION                        {:   RESULT = new DeclaracionVariable(false, a, b, aleft, aright);   :}
;

ASIGNACION ::= ID:a IGUAL EXPRESION:b FIN_INSTRUCCION  {:   RESULT = new AsignacionVariable(a, b, aleft, aright);  :}
;

SIF ::= IF LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE      {:   RESULT = new If(a, b, aleft, aright);   :}
;

TIPOS ::= INT       {:   RESULT = new Tipo(TipoDeDato.INT);   :}
        | DOUBLE    {:   RESULT = new Tipo(TipoDeDato.DOUBLE);   :}
        | BOOL      {:   RESULT = new Tipo(TipoDeDato.BOOLEAN);   :}
        | CHAR      {:   RESULT = new Tipo(TipoDeDato.CHAR);   :}
        | STRING    {:   RESULT = new Tipo(TipoDeDato.STRING);   :}
;

EXPRESION ::= MENOS EXPRESION:a                     {:  RESULT = new Aritmeticas(a, OperadoresAritmeticos.NEGACION, aleft, aright); :} %prec UMENOS
            | EXPRESION:a MAS EXPRESION:b           {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA, aleft, aright);  :}
            | EXPRESION:a MENOS EXPRESION:b         {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.RESTA, aleft, aright); :}
            | EXPRESION:a TIMES EXPRESION:b         {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright);    :}
            | EXPRESION:a TIMES TIMES EXPRESION:b   {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright);  :}
            | EXPRESION:a MOD EXPRESION:b           {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MODULO, aleft, aright);    :}
            | EXPRESION:a DIVIDE EXPRESION:b        {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.DIVISION, aleft, aright);  :}
            | EXPRESION:a EQ EXPRESION:b            {:  RESULT = new Relacionales(a, b, OpRelacional.IGUAL, aleft, aright); :}%prec EQ
            | EXPRESION:a NE EXPRESION:b            {:  RESULT = new Relacionales(a, b, OpRelacional.DIFERENCIACION, aleft, aright); :}
            | EXPRESION:a MENOR EXPRESION:b         {:  RESULT = new Relacionales(a, b, OpRelacional.MENOR, aleft, aright); :}
            | EXPRESION:a MAYOR EXPRESION:b         {:  RESULT = new Relacionales(a, b, OpRelacional.MAYOR, aleft, aright); :}
            | EXPRESION:a MENOR_IGUAL EXPRESION:b   {:  RESULT = new Relacionales(a, b, OpRelacional.MENOR_IGUAL, aleft, aright);   :}
            | EXPRESION:a MAYOR_IGUAL EXPRESION:b   {:  RESULT = new Relacionales(a, b, OpRelacional.MAYOR_IGUAL, aleft, aright);   :}
            | EXPRESION:a OR EXPRESION:b            {:  RESULT = new Logicos(a, b, OpLogicos.OR, aleft, aright); :}%prec OR
            | EXPRESION:a AND EXPRESION:b           {:  RESULT = new Logicos(a, b, OpLogicos.AND, aleft, aright); :}
            | EXPRESION:a XOR EXPRESION:b           {:  RESULT = new Logicos(a, b, OpLogicos.XOR, aleft, aright); :}
            | LPAREN TIPOS:a RPAREN EXPRESION:b     {:  RESULT = new Casteo(a, b, aleft, aright);  :} %prec CAST
            | NOT EXPRESION:a                       {:  RESULT = new Logicos(a, OpLogicos.NOT, aleft, aright); :}
            | LPAREN EXPRESION:a RPAREN             {:  RESULT = a; :}
            | ENTERO:a                              {:  RESULT = new Nativo(Integer.parseInt(a), new Tipo(TipoDeDato.INT), aleft, aright ); :}
            | DECIMAL:a                             {:  RESULT = new Nativo(Double.parseDouble(a), new Tipo(TipoDeDato.DOUBLE), aleft, aright );    :}
            | CARACTER:a                            {:  RESULT = new Nativo(a, new Tipo(TipoDeDato.CHAR), aleft, aright );  :}
            | CADENA:a                              {:  RESULT = new Nativo(a, new Tipo(TipoDeDato.STRING), aleft, aright );    :}
            | BOOLEAN:a                             {:  RESULT = new Nativo(Boolean.parseBoolean((String) a), new Tipo(TipoDeDato.BOOLEAN), aleft, aright );    :}
            | ID:a                                  {:  RESULT = new AccesoVariable(a, aleft, aright);   :}
;