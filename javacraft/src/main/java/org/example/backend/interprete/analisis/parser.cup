package org.example.backend.interprete.analisis;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import org.example.backend.interprete.abstracto.Instruccion;
import org.example.backend.interprete.expresion.*;
import org.example.backend.interprete.error.*;
import org.example.backend.interprete.simbol.*;

import org.example.backend.interprete.instruccion.*;

class Parser;

parser code {:

    public LinkedList<Errores> listaErrores = new LinkedList<>();

//TipoError tipo, String desc, int lineaa, int columaa
    public void syntax_error(Symbol s){
        listaErrores.add(new Errores(
                        TipoError.SINTACTICO,
                        ", Recuperable. No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        listaErrores.add(new Errores(
                        TipoError.SINTACTICO,
                        ", No Recuperable. No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }
:}


//** Simboloes terminal **//
terminal String CADENA, ENTERO, DECIMAL, ID;
terminal LPAREN, RPAREN, TIMES, INT, DOUBLE, BOOL, CHAR, STRING, VAR, CONST, MAS, MENOS, DIVIDE, MOD, UMENOS;
terminal NE, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL, OR, AND, XOR, NOT, IF, ELSE, WHILE, DO, FOR;
terminal MATCH, DEFAULT, LBRACE, RBRACE, PRINTLN, CARACTER, COMA, DOS_PUNTOS, BREAK, CONTINUE, RETURN;
terminal BOOLEAN, LSQUARE, RSQUARE, FIN_INSTRUCCION, IGUAL, EQ, CAST;

//** Simbolos no terminales **//
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal LinkedList<Instruccion> CASOS;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion SIF, SBREAK, SCONTINUAR, SMATCH, CASO;
nonterminal Instruccion SFOR, REFRESH_FOR, SWHILE, SDO;
nonterminal Instruccion PRINT, DECLARACION, ASIGNACION;
nonterminal LinkedList<Instruccion> LISTA;
//nonterminal Instruccion VALORES;
nonterminal Instruccion DECLARACION_VECTOR;
nonterminal Instruccion EXPRESION;
nonterminal Instruccion EXPR2;
nonterminal Tipo TIPOS;

//** Precedencia **//
precedence left OR, AND, XOR;
precedence right NOT;
precedence left EQ, NE, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left TIMES, DIVIDE, MOD;
precedence right UMENOS;
precedence right CAST;

//** Definir gramaticas **//
start with INICIO;

INICIO ::= INSTRUCCIONES:a      {:   RESULT = a;   :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b     {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                     {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

INSTRUCCION ::= PRINT: a                {:   RESULT = a;   :}
              | DECLARACION: a          {:   RESULT = a;   :}
              | ASIGNACION: a           {:   RESULT = a;   :}
              | SIF:a                   {:   RESULT = a;   :}
              | SBREAK:a                {:   RESULT = a;   :}
              | SCONTINUAR:a            {:   RESULT = a;   :}
              | SMATCH:a                {:   RESULT = a;   :}
              | SWHILE:a                {:   RESULT = a;   :}
              | SFOR:a                  {:   RESULT = a;   :}
              | SDO:a                   {:   RESULT = a;   :}
              | DECLARACION_VECTOR:a    {:   RESULT = a;   :}
              | error FIN_INSTRUCCION
;

PRINT ::= PRINTLN LPAREN EXPRESION:a RPAREN FIN_INSTRUCCION      {:     RESULT = new Print(a, aleft, aright);   :}
;

DECLARACION ::= CONST ID:b DOS_PUNTOS TIPOS:a IGUAL EXPRESION:c FIN_INSTRUCCION    {:   RESULT = new DeclaracionVariable(true, b, c, a, aleft, aright);    :}
              | VAR ID:b DOS_PUNTOS TIPOS:a IGUAL EXPRESION:c FIN_INSTRUCCION      {:   RESULT = new DeclaracionVariable(false, b, c, a, aleft, aright);   :}
              | CONST ID:a DOS_PUNTOS TIPOS:b FIN_INSTRUCCION                      {:   RESULT = new DeclaracionVariable(true, a, b, aleft, aright);   :}
              | VAR ID:a DOS_PUNTOS TIPOS:b FIN_INSTRUCCION                        {:   RESULT = new DeclaracionVariable(false, a, b, aleft, aright);   :}
;

ASIGNACION ::= ID:a IGUAL EXPRESION:b FIN_INSTRUCCION  {:   RESULT = new AsignacionVariable(a, b, aleft, aright);  :}
             | ID:a MAS MAS FIN_INSTRUCCION            {:   RESULT = new AsignacionVariable(a,
                                                                        new Aritmeticas(new AccesoVariable(a, aleft, aright),
                                                                            OperadoresAritmeticos.INCREMENTO, aleft, aright),
                                                                                aleft, aright);:}
             | ID:a MENOS MENOS FIN_INSTRUCCION        {:   RESULT = new AsignacionVariable(a,
                                                                        new Aritmeticas(new AccesoVariable(a, aleft, aright),
                                                                            OperadoresAritmeticos.DECREMENTO, aleft, aright),
                                                                                aleft, aright);:}
;

SBREAK ::= BREAK:a FIN_INSTRUCCION      {:    RESULT = new Break(aleft, aright);     :}
;

SCONTINUAR ::= CONTINUE:a FIN_INSTRUCCION   {:  RESULT = new Continue(aleft, aright);   :}
;

SIF ::= IF LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE      {:   RESULT = new If(a, b, aleft, aright);   :}
      | IF LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE
        ELSE SIF                                                        {:   RESULT = new If(a, b, aleft, aright);   :}
      | IF LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE
            ELSE LBRACE INSTRUCCIONES:c RBRACE                          {:   RESULT = new If(a, b, c, aleft, aright);   :}
;

CASOS ::= CASOS:a CASO:b     {: RESULT = a; RESULT.add(b); :}
        | CASO:a             {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

CASO ::= EXPRESION:a IGUAL MAYOR LBRACE INSTRUCCIONES:b RBRACE          {:  RESULT = new Caso(a, b, aleft, aright);    :}
        | DEFAULT LBRACE INSTRUCCIONES:a RBRACE                         {:  RESULT = new DefaultCase(a, aleft, aright); :}
;

SMATCH ::= MATCH LPAREN EXPRESION:a RPAREN LBRACE CASOS:c RBRACE               {:  RESULT = new Match(a, c, aleft, aright);   :}
;

SWHILE ::= WHILE LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE    {:  RESULT = new While(a, b, aleft, aright);    :}
;

SDO ::= DO LBRACE INSTRUCCIONES:a RBRACE WHILE
            LPAREN EXPRESION:b RPAREN FIN_INSTRUCCION       {:  RESULT = new DoWhile(a, b, aleft, aright); :}
;

SFOR ::= FOR LPAREN DECLARACION:a EXPRESION:b FIN_INSTRUCCION REFRESH_FOR:c RPAREN
                            LBRACE INSTRUCCIONES:d RBRACE                          {:  RESULT = new For(a, b, c, d, aleft, aright);:}
       | FOR LPAREN ASIGNACION:a EXPRESION:b FIN_INSTRUCCION REFRESH_FOR:c RPAREN
                                    LBRACE INSTRUCCIONES:d RBRACE                  {:  RESULT = new For(a, b, c, d, aleft, aright);:}
;

REFRESH_FOR ::= ID:a IGUAL EXPRESION:b   {:   RESULT = new AsignacionVariable(a, b, aleft, aright);  :}
              | ID:a MAS MAS             {:   RESULT = new AsignacionVariable(a, new Aritmeticas(new AccesoVariable(a, aleft, aright),
                                                                                      OperadoresAritmeticos.INCREMENTO, aleft, aright),
                                                                                      aleft, aright);:}
              | ID:a MENOS MENOS         {:   RESULT = new AsignacionVariable(a, new Aritmeticas(new AccesoVariable(a, aleft, aright),
                                                                                      OperadoresAritmeticos.DECREMENTO, aleft, aright),
                                                                                      aleft, aright);:}
;

LISTA ::= LISTA:a COMA EXPRESION:b     {:  RESULT = a; RESULT.add(b);  :}
        | EXPRESION:a         {:  RESULT = new LinkedList<>(); RESULT.add(a); :}
;

//boolean esConstante, String id, LinkedList<Instruccion> valores, Tipo tipo, int linea, int columna
DECLARACION_VECTOR ::= CONST ID:a DOS_PUNTOS TIPOS:b LSQUARE RSQUARE
                       IGUAL LSQUARE LISTA:c RSQUARE FIN_INSTRUCCION   {:  RESULT = new DecArreglo(true, a, c, b, aleft, aright);    :}

                     | VAR ID:a DOS_PUNTOS TIPOS:b LSQUARE RSQUARE
                       IGUAL LSQUARE LISTA:c RSQUARE FIN_INSTRUCCION   {:  RESULT = new DecArreglo(false, a, c, b, aleft, aright);    :}
;

TIPOS ::= INT       {:      RESULT = new Tipo(TipoDeDato.INT);        :}
        | DOUBLE    {:      RESULT = new Tipo(TipoDeDato.DOUBLE);     :}
        | BOOL      {:      RESULT = new Tipo(TipoDeDato.BOOLEAN);    :}
        | CHAR      {:      RESULT = new Tipo(TipoDeDato.CHAR);       :}
        | STRING    {:      RESULT = new Tipo(TipoDeDato.STRING);     :}
;

EXPRESION ::= MENOS EXPRESION:a                     {:  RESULT = new Aritmeticas(a, OperadoresAritmeticos.NEGACION, aleft, aright); :} %prec UMENOS
            | EXPRESION:a MAS EXPRESION:b           {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA, aleft, aright);  :}
            | EXPRESION:a MENOS EXPRESION:b         {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.RESTA, aleft, aright); :}
            | EXPRESION:a TIMES EXPRESION:b         {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright);    :}
            | EXPRESION:a TIMES TIMES EXPRESION:b   {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright);  :}
            | EXPRESION:a MOD EXPRESION:b           {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MODULO, aleft, aright);    :}
            | EXPRESION:a DIVIDE EXPRESION:b        {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.DIVISION, aleft, aright);  :}
            | EXPRESION:a MAS MAS                   {:  RESULT = new Aritmeticas(a, OperadoresAritmeticos.INCREMENTO, aleft, aright);   :}
            | EXPRESION:a MENOS MENOS               {:  RESULT = new Aritmeticas(a, OperadoresAritmeticos.DECREMENTO, aleft, aright);   :}
            | EXPRESION:a EQ EXPRESION:b            {:  RESULT = new Relacionales(a, b, OpRelacional.IGUAL, aleft, aright); :}%prec EQ
            | EXPRESION:a NE EXPRESION:b            {:  RESULT = new Relacionales(a, b, OpRelacional.DIFERENCIACION, aleft, aright); :}
            | EXPRESION:a MENOR EXPRESION:b         {:  RESULT = new Relacionales(a, b, OpRelacional.MENOR, aleft, aright); :}
            | EXPRESION:a MAYOR EXPRESION:b         {:  RESULT = new Relacionales(a, b, OpRelacional.MAYOR, aleft, aright); :}
            | EXPRESION:a MENOR_IGUAL EXPRESION:b   {:  RESULT = new Relacionales(a, b, OpRelacional.MENOR_IGUAL, aleft, aright);   :}
            | EXPRESION:a MAYOR_IGUAL EXPRESION:b   {:  RESULT = new Relacionales(a, b, OpRelacional.MAYOR_IGUAL, aleft, aright);   :}
            | EXPRESION:a OR EXPRESION:b            {:  RESULT = new Logicos(a, b, OpLogicos.OR, aleft, aright); :}%prec OR
            | EXPRESION:a AND EXPRESION:b           {:  RESULT = new Logicos(a, b, OpLogicos.AND, aleft, aright); :}
            | EXPRESION:a XOR EXPRESION:b           {:  RESULT = new Logicos(a, b, OpLogicos.XOR, aleft, aright); :}
            | LPAREN TIPOS:a RPAREN EXPRESION:b     {:  RESULT = new Casteo(a, b, aleft, aright);  :} %prec CAST
            | NOT EXPRESION:a                       {:  RESULT = new Logicos(a, OpLogicos.NOT, aleft, aright); :}
            | LPAREN EXPRESION:a RPAREN             {:  RESULT = a; :}
            | ENTERO:a                              {:  RESULT = new Nativo(Integer.parseInt(a), new Tipo(TipoDeDato.INT), aleft, aright ); :}
            | DECIMAL:a                             {:  RESULT = new Nativo(Double.parseDouble(a), new Tipo(TipoDeDato.DOUBLE), aleft, aright );    :}
            | CARACTER:a                            {:  RESULT = new Nativo(a, new Tipo(TipoDeDato.CHAR), aleft, aright );  :}
            | CADENA:a                              {:  RESULT = new Nativo(a, new Tipo(TipoDeDato.STRING), aleft, aright );    :}
            | BOOLEAN:a                             {:  RESULT = new Nativo(Boolean.parseBoolean((String) a), new Tipo(TipoDeDato.BOOLEAN), aleft, aright );    :}
            | ID:a                                  {:  RESULT = new AccesoVariable(a, aleft, aright);   :}
            | EXPR2:a                               {:  RESULT = a; :}
;

//String id, Instruccion posicion, int linea, int columna
EXPR2 ::= ID:a LSQUARE EXPRESION:b RSQUARE      {:  RESULT = new AccesoValorVector(a, b, aleft, aright);   :}
;