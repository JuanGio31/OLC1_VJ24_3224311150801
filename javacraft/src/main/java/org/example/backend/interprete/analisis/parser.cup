package org.example.backend.interprete.analisis;

import java_cup.runtime.Symbol;
import java.util.LinkedList;
import java.util.HashMap;
import org.example.backend.interprete.abstracto.Instruccion;
import org.example.backend.interprete.expresion.*;
import org.example.backend.interprete.error.*;
import org.example.backend.interprete.simbol.*;

import org.example.backend.interprete.instruccion.*;

class Parser;

parser code {:

    public LinkedList<Errores> listaErrores = new LinkedList<>();

//TipoError tipo, String desc, int lineaa, int columaa
    public void syntax_error(Symbol s){
        listaErrores.add(new Errores(
                        TipoError.SINTACTICO,
                        ", Recuperable. No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }

    public void unrecovered_syntax_error (Symbol s){
        listaErrores.add(new Errores(
                        TipoError.SINTACTICO,
                        ", No Recuperable. No se esperaba el componente "+s.value,
                        s.left,
                        s.right));
    }
:}


//** Simboloes terminal **//
terminal String CADENA, ENTERO, DECIMAL, ID;
terminal LPAREN, RPAREN, TIMES, INT, DOUBLE, BOOL, CHAR, STRING, VAR, CONST, MAS, MENOS, DIVIDE, MOD, UMENOS;
terminal NE, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL, OR, AND, XOR, NOT, IF, ELSE, WHILE, DO, FOR;
terminal MATCH, DEFAULT, LBRACE, RBRACE, PRINTLN, CARACTER, COMA, DOS_PUNTOS, BREAK, CONTINUE, RETURN;
terminal BOOLEAN, LSQUARE, RSQUARE, FIN_INSTRUCCION, IGUAL, EQ, CAST, COMILLADOB;
terminal LIST, NEW, APPEND, REMOVE, STRUCT, ROUND, LENGTH, TO_STRING, PUNTO, FIND, VOID, START_WITH;

//** Simbolos no terminales **//
nonterminal LinkedList<Instruccion> INICIO, INSTRUCCIONES;
nonterminal LinkedList<Instruccion> CASOS;
nonterminal Instruccion INSTRUCCION;
nonterminal Instruccion SIF, SBREAK, SCONTINUAR, SMATCH, CASO;
nonterminal Instruccion SFOR, REFRESH_FOR, SWHILE, SDO;
nonterminal Instruccion PRINT, FROUND, FLENGTH, FFIND;
nonterminal Instruccion DECLARACION, ASIGNACION;
nonterminal LinkedList<Instruccion> LISTA;
nonterminal LinkedList<LinkedList> MATRIZ;
nonterminal LinkedList<HashMap> DECPARAMETROS;
nonterminal LinkedList<Instruccion> CALLPARAMS;
nonterminal Instruccion DECLARACION_VECTOR, ASIGN_VECTOR;
nonterminal Instruccion DEC_LIST, AGREGAR, ELIMINAR;
nonterminal Instruccion EXPRESION;
nonterminal Instruccion EXPR2, EXPR3, EXPR4, EXPR5;
nonterminal Instruccion METODO;
nonterminal Instruccion MAIN;
nonterminal Instruccion RETORNO;
nonterminal Instruccion LLAMADA;
nonterminal Tipo TIPOS;

//** Precedencia **//
precedence left OR, AND, XOR;
precedence right NOT;
precedence left EQ, NE, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left TIMES, DIVIDE, MOD;
precedence right UMENOS;
precedence right CAST;

//** Definir gramaticas **//
start with INICIO;

INICIO ::= INSTRUCCIONES:a      {:   RESULT = a;   :}
;

INSTRUCCIONES ::= INSTRUCCIONES:a INSTRUCCION:b     {: RESULT = a; RESULT.add(b); :}
                | INSTRUCCION:a                     {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

INSTRUCCION ::= PRINT: a                {:   RESULT = a;   :}
              | DECLARACION: a          {:   RESULT = a;   :}
              | ASIGNACION: a           {:   RESULT = a;   :}
              | SIF:a                   {:   RESULT = a;   :}
              | SBREAK:a                {:   RESULT = a;   :}
              | SCONTINUAR:a            {:   RESULT = a;   :}
              | SMATCH:a                {:   RESULT = a;   :}
              | SWHILE:a                {:   RESULT = a;   :}
              | SFOR:a                  {:   RESULT = a;   :}
              | SDO:a                   {:   RESULT = a;   :}
              | DECLARACION_VECTOR:a    {:   RESULT = a;   :}
              | ASIGN_VECTOR:a          {:   RESULT = a;   :}
              | DEC_LIST:a              {:   RESULT = a;   :}
              | AGREGAR:a               {:   RESULT = a;   :}
              | ELIMINAR:a              {:   RESULT = a;   :}
              | METODO:a                {:   RESULT = a;   :}
              | MAIN:a                  {:   RESULT = a;   :}
              | RETORNO:a               {:   RESULT = a;   :}
              | LLAMADA:a               {:   RESULT = a;   :}
              | error FIN_INSTRUCCION
;

PRINT ::= PRINTLN LPAREN EXPRESION:a RPAREN FIN_INSTRUCCION      {:     RESULT = new Print(a, aleft, aright);   :}
;

DECLARACION ::= CONST ID:b DOS_PUNTOS TIPOS:a IGUAL EXPRESION:c FIN_INSTRUCCION    {:   RESULT = new DeclaracionVariable(true, b, c, a, aleft, aright);    :}
              | VAR ID:b DOS_PUNTOS TIPOS:a IGUAL EXPRESION:c FIN_INSTRUCCION      {:   RESULT = new DeclaracionVariable(false, b, c, a, aleft, aright);   :}
              | CONST ID:a DOS_PUNTOS TIPOS:b FIN_INSTRUCCION                      {:   RESULT = new DeclaracionVariable(true, a, b, aleft, aright);   :}
              | VAR ID:a DOS_PUNTOS TIPOS:b FIN_INSTRUCCION                        {:   RESULT = new DeclaracionVariable(false, a, b, aleft, aright);   :}
;

ASIGNACION ::= ID:a IGUAL EXPRESION:b FIN_INSTRUCCION  {:   RESULT = new AsignacionVariable(a, b, aleft, aright);  :}
             | ID:a MAS MAS FIN_INSTRUCCION            {:   RESULT = new AsignacionVariable(a,
                                                                        new Aritmeticas(new AccesoVariable(a, aleft, aright),
                                                                            OperadoresAritmeticos.INCREMENTO, aleft, aright),
                                                                                aleft, aright);:}
             | ID:a MENOS MENOS FIN_INSTRUCCION        {:   RESULT = new AsignacionVariable(a,
                                                                        new Aritmeticas(new AccesoVariable(a, aleft, aright),
                                                                            OperadoresAritmeticos.DECREMENTO, aleft, aright),
                                                                                aleft, aright);:}
;

SBREAK ::= BREAK:a FIN_INSTRUCCION      {:    RESULT = new Break(aleft, aright);     :}
;

SCONTINUAR ::= CONTINUE:a FIN_INSTRUCCION   {:  RESULT = new Continue(aleft, aright);   :}
;

SIF ::= IF LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE      {:   RESULT = new If(a, b, aleft, aright);   :}
      | IF LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE
        ELSE SIF                                                        {:   RESULT = new If(a, b, aleft, aright);   :}
      | IF LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE
            ELSE LBRACE INSTRUCCIONES:c RBRACE                          {:   RESULT = new If(a, b, c, aleft, aright);   :}
;

CASOS ::= CASOS:a CASO:b     {: RESULT = a; RESULT.add(b); :}
        | CASO:a             {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

CASO ::= EXPRESION:a IGUAL MAYOR LBRACE INSTRUCCIONES:b RBRACE          {:  RESULT = new Caso(a, b, aleft, aright);    :}
        | DEFAULT LBRACE INSTRUCCIONES:a RBRACE                         {:  RESULT = new DefaultCase(a, aleft, aright); :}
;

SMATCH ::= MATCH LPAREN EXPRESION:a RPAREN LBRACE CASOS:c RBRACE               {:  RESULT = new Match(a, c, aleft, aright);   :}
;

SWHILE ::= WHILE LPAREN EXPRESION:a RPAREN LBRACE INSTRUCCIONES:b RBRACE    {:  RESULT = new While(a, b, aleft, aright);    :}
;

SDO ::= DO LBRACE INSTRUCCIONES:a RBRACE WHILE
            LPAREN EXPRESION:b RPAREN FIN_INSTRUCCION       {:  RESULT = new DoWhile(a, b, aleft, aright); :}
;

SFOR ::= FOR LPAREN DECLARACION:a EXPRESION:b FIN_INSTRUCCION REFRESH_FOR:c RPAREN
                            LBRACE INSTRUCCIONES:d RBRACE                          {:  RESULT = new For(a, b, c, d, aleft, aright);:}
       | FOR LPAREN ASIGNACION:a EXPRESION:b FIN_INSTRUCCION REFRESH_FOR:c RPAREN
                                    LBRACE INSTRUCCIONES:d RBRACE                  {:  RESULT = new For(a, b, c, d, aleft, aright);:}
;

REFRESH_FOR ::= ID:a IGUAL EXPRESION:b   {:   RESULT = new AsignacionVariable(a, b, aleft, aright);  :}
              | ID:a MAS MAS             {:   RESULT = new AsignacionVariable(a, new Aritmeticas(new AccesoVariable(a, aleft, aright),
                                                                                      OperadoresAritmeticos.INCREMENTO, aleft, aright),
                                                                                      aleft, aright);:}
              | ID:a MENOS MENOS         {:   RESULT = new AsignacionVariable(a, new Aritmeticas(new AccesoVariable(a, aleft, aright),
                                                                                      OperadoresAritmeticos.DECREMENTO, aleft, aright),
                                                                                      aleft, aright);:}
;

LISTA ::= LISTA:a COMA EXPRESION:b     {:  RESULT = a; RESULT.add(b);  :}
        | EXPRESION:a                  {:  RESULT = new LinkedList<>(); RESULT.add(a); :}
;

MATRIZ ::= MATRIZ:a COMA LSQUARE LISTA:b RSQUARE    {:  RESULT = a; RESULT.add(b);  :}
         | LSQUARE LISTA:a RSQUARE                  {:  RESULT = new LinkedList<>(); RESULT.add(a); :}
;

DECLARACION_VECTOR ::= CONST ID:a DOS_PUNTOS TIPOS:b LSQUARE RSQUARE
                       IGUAL LSQUARE LISTA:c RSQUARE FIN_INSTRUCCION   {:  RESULT = new DecColeccion(TipoDeDato.VECTOR, true, a, c, b, aleft, aright);    :}

                     | VAR ID:a DOS_PUNTOS TIPOS:b LSQUARE RSQUARE
                       IGUAL LSQUARE LISTA:c RSQUARE FIN_INSTRUCCION   {:  RESULT = new DecColeccion(TipoDeDato.VECTOR, false, a, c, b, aleft, aright);    :}

                     | CONST ID:a DOS_PUNTOS TIPOS:b LSQUARE RSQUARE LSQUARE RSQUARE
                         IGUAL LSQUARE MATRIZ:c RSQUARE FIN_INSTRUCCION   {:  RESULT = new DecMatriz(TipoDeDato.MATRIZ, true, a, c, b, aleft, aright);    :}

                     | VAR ID:a DOS_PUNTOS TIPOS:b LSQUARE RSQUARE LSQUARE RSQUARE
                         IGUAL LSQUARE MATRIZ:c RSQUARE FIN_INSTRUCCION   {:  RESULT = new DecMatriz(TipoDeDato.MATRIZ, false, a, c, b, aleft, aright);    :}
;

ASIGN_VECTOR ::= ID:a LSQUARE EXPRESION:b RSQUARE IGUAL EXPRESION:c FIN_INSTRUCCION
                                                  {:  RESULT = new AsignacionValorEnPosicion(a, c, b, aleft, aright); :}
               | ID:a LSQUARE EXPRESION:b RSQUARE LSQUARE EXPRESION:c RSQUARE IGUAL EXPRESION:d FIN_INSTRUCCION
                                                  {:  RESULT = new AsignValorMatriz(a, b, c, d, aleft, aright);    :}
;

DEC_LIST ::= LIST MENOR TIPOS:b MAYOR ID:a IGUAL NEW LIST LPAREN RPAREN FIN_INSTRUCCION {:  RESULT = new DecColeccion(TipoDeDato.LIST, a, b, aleft, aright);    :}
;

AGREGAR ::= ID:a PUNTO APPEND LPAREN EXPRESION:b RPAREN FIN_INSTRUCCION     {:  RESULT = new Append(a, b, aleft, aright);  :}
;

ELIMINAR ::= EXPR3:a FIN_INSTRUCCION      {:  RESULT = a;  :}
;

FROUND ::= ROUND LPAREN EXPRESION:a RPAREN      {:  RESULT = new FRound(a, aleft, aright);  :}
;

FLENGTH ::= LENGTH LPAREN EXPRESION:a RPAREN           {:  RESULT = new FLength(a, aleft, aright);  :}
;

FFIND ::= ID:a PUNTO FIND LPAREN EXPRESION:b RPAREN     {:  RESULT = new FBuscar(a, b, aleft, aright);:}
;

METODO ::= TIPOS:t ID:a LPAREN RPAREN LBRACE INSTRUCCIONES:c RBRACE                 {:  RESULT = new Metodo(a, new LinkedList<HashMap>(), c, t, aleft, aright);  :}
         | TIPOS:t ID:a LPAREN DECPARAMETROS:p RPAREN LBRACE INSTRUCCIONES:c RBRACE {:  RESULT = new Metodo(a, p, c, t, aleft, aright);  :}
;

DECPARAMETROS ::= DECPARAMETROS:a COMA TIPOS:b ID:c     {:  RESULT = a; var map2 = new HashMap<String, Object>();
                                                            map2.put("id", c); map2.put("tipo", b); RESULT.add(map2);   :}
                | TIPOS:a ID:b                          {: RESULT = new LinkedList<HashMap>(); var map = new HashMap<String, Object>();
                                                           map.put("id", b); map.put("tipo", a); RESULT.add(map);  :}
;

MAIN ::= START_WITH ID:a LPAREN CALLPARAMS:b RPAREN FIN_INSTRUCCION {:  RESULT = new MetodoStart(a, b, aleft, aright); :}
       | START_WITH ID:a LPAREN RPAREN FIN_INSTRUCCION              {:  RESULT = new MetodoStart(a, new LinkedList<Instruccion>(), aleft, aright); :}
;

CALLPARAMS ::= CALLPARAMS:a COMA EXPRESION:e    {:  RESULT = a; RESULT.add(e); :}
            | EXPRESION:a                       {:  RESULT = new LinkedList<Instruccion>(); RESULT.add(a);   :}
;

LLAMADA ::= EXPR5:a FIN_INSTRUCCION             {:  RESULT = a; :}
;

RETORNO ::= RETURN EXPRESION:a FIN_INSTRUCCION      {:  RESULT = new Retorno(a, aleft, aright); :}
          | RETURN:a FIN_INSTRUCCION                {:  RESULT = new Retorno(null, aleft, aright); :}
          | RETURN EXPR5:a FIN_INSCRICCION          {:  RESULT = new Retorno(a, aleft, aright); :}
;


TIPOS ::= INT       {:      RESULT = new Tipo(TipoDeDato.INT);        :}
        | DOUBLE    {:      RESULT = new Tipo(TipoDeDato.DOUBLE);     :}
        | BOOL      {:      RESULT = new Tipo(TipoDeDato.BOOLEAN);    :}
        | CHAR      {:      RESULT = new Tipo(TipoDeDato.CHAR);       :}
        | STRING    {:      RESULT = new Tipo(TipoDeDato.STRING);     :}
        | VOID      {:      RESULT = new Tipo(TipoDeDato.VOID);       :}
;

EXPRESION ::= MENOS EXPRESION:a                     {:  RESULT = new Aritmeticas(a, OperadoresAritmeticos.NEGACION, aleft, aright); :} %prec UMENOS
            | EXPRESION:a MAS EXPRESION:b           {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.SUMA, aleft, aright);  :}
            | EXPRESION:a MENOS EXPRESION:b         {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.RESTA, aleft, aright); :}
            | EXPRESION:a TIMES EXPRESION:b         {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MULTIPLICACION, aleft, aright);    :}
            | EXPRESION:a TIMES TIMES EXPRESION:b   {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.POTENCIA, aleft, aright);  :}
            | EXPRESION:a MOD EXPRESION:b           {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.MODULO, aleft, aright);    :}
            | EXPRESION:a DIVIDE EXPRESION:b        {:  RESULT = new Aritmeticas(a, b, OperadoresAritmeticos.DIVISION, aleft, aright);  :}
            | EXPRESION:a MAS MAS                   {:  RESULT = new Aritmeticas(a, OperadoresAritmeticos.INCREMENTO, aleft, aright);   :}
            | EXPRESION:a MENOS MENOS               {:  RESULT = new Aritmeticas(a, OperadoresAritmeticos.DECREMENTO, aleft, aright);   :}
            | EXPRESION:a EQ EXPRESION:b            {:  RESULT = new Relacionales(a, b, OpRelacional.IGUAL, aleft, aright); :}%prec EQ
            | EXPRESION:a NE EXPRESION:b            {:  RESULT = new Relacionales(a, b, OpRelacional.DIFERENCIACION, aleft, aright); :}
            | EXPRESION:a MENOR EXPRESION:b         {:  RESULT = new Relacionales(a, b, OpRelacional.MENOR, aleft, aright); :}
            | EXPRESION:a MAYOR EXPRESION:b         {:  RESULT = new Relacionales(a, b, OpRelacional.MAYOR, aleft, aright); :}
            | EXPRESION:a MENOR_IGUAL EXPRESION:b   {:  RESULT = new Relacionales(a, b, OpRelacional.MENOR_IGUAL, aleft, aright);   :}
            | EXPRESION:a MAYOR_IGUAL EXPRESION:b   {:  RESULT = new Relacionales(a, b, OpRelacional.MAYOR_IGUAL, aleft, aright);   :}
            | EXPRESION:a OR EXPRESION:b            {:  RESULT = new Logicos(a, b, OpLogicos.OR, aleft, aright); :}%prec OR
            | EXPRESION:a AND EXPRESION:b           {:  RESULT = new Logicos(a, b, OpLogicos.AND, aleft, aright); :}
            | EXPRESION:a XOR EXPRESION:b           {:  RESULT = new Logicos(a, b, OpLogicos.XOR, aleft, aright); :}
            | LPAREN TIPOS:a RPAREN EXPRESION:b     {:  RESULT = new Casteo(a, b, aleft, aright);  :} %prec CAST
            | NOT EXPRESION:a                       {:  RESULT = new Logicos(a, OpLogicos.NOT, aleft, aright); :}
            | LPAREN EXPRESION:a RPAREN             {:  RESULT = a; :}
            | ENTERO:a                              {:  RESULT = new Nativo(Integer.parseInt(a), new Tipo(TipoDeDato.INT), aleft, aright ); :}
            | DECIMAL:a                             {:  RESULT = new Nativo(Double.parseDouble(a), new Tipo(TipoDeDato.DOUBLE), aleft, aright );    :}
            | CARACTER:a                            {:  RESULT = new Nativo(a, new Tipo(TipoDeDato.CHAR), aleft, aright );  :}
            | CADENA:a                              {:  RESULT = new Nativo(a, new Tipo(TipoDeDato.STRING), aleft, aright );    :}
            | BOOLEAN:a                             {:  RESULT = new Nativo(Boolean.parseBoolean((String) a), new Tipo(TipoDeDato.BOOLEAN), aleft, aright );    :}
            | ID:a                                  {:  RESULT = new AccesoVariable(a, aleft, aright);   :}
            | EXPR2:a                               {:  RESULT = a; :}
            | EXPR3:a                               {:  RESULT = a; :}
            | FROUND:a                              {:  RESULT = a; :}
            | FLENGTH:a                             {:  RESULT = a; :}
            | FFIND:a                               {:  RESULT = a; :}
            | EXPR4:a                               {:  RESULT = a; :}
            | EXPR5:a                               {:  RESULT = a; :}
;

EXPR2 ::= ID:a LSQUARE EXPRESION:b RSQUARE                {:  RESULT = new AccesoValorVector(a, b, aleft, aright);   :}
;

EXPR3 ::= ID:a PUNTO REMOVE LPAREN EXPRESION:b RPAREN     {:  RESULT = new Remove(a, b, aleft, aright);  :}
;

EXPR4 ::= ID:a LSQUARE EXPRESION:b RSQUARE LSQUARE EXPRESION:c RSQUARE  {:  RESULT = new AccesoValorMatriz(a, c, b, aleft, aright);   :}
;

EXPR5 ::= ID:a LPAREN CALLPARAMS:b RPAREN                {:  RESULT= new Llamada(a, b, aleft, aright);    :}
        | ID:a LPAREN RPAREN                             {:  RESULT= new Llamada(a, new LinkedList<Instruccion>(), aleft, aright);    :}
;